# PR Reviewer Assignment Service

## Архитектурные решения и допущения

### Публичный API

Сервис задуман как полностью открытый внутри контура: все эндпоинты доступны без авторизации и дополнительного заголовка `Authorization`, так как я обнаружил позднее что была исправлена спека openapi.yaml.

### Доменная модель vs API контракт

**Поле `need_more_reviewers`**
- Упоминается в описании задания и используется внутри домена (true, если ревьюверов < 2), но в публичном API/DTO не возвращается, чтобы соответствовать OpenAPI.

**Бизнес-логика**
- Автоназначение: До 2 активных ревьюверов из команды автора (исключая автора)
- Переназначение: Замена из **команды заменяемого ревьювера** (не автора)
- После merge: Изменение ревьюверов запрещено при статусе `MERGED`
- Идемпотентность: Повторные вызовы возвращают текущее состояние без ошибок

### Тестовая БД для интеграционных тестов

- В `docker-compose.yml` есть второй PostgreSQL сервис `postgres_test` (порт `5434`) специально для интеграционных тестов. 
- При поднятии стенда `docker-compose up` создаёт две базы: рабочую (`pr_reviewer_db`) и тестовую (`pr_reviewer_test_db`). 
- Я это сделал, что бы типо изолировать среду на тестовую/прод.(если я конечно, всё правильно понял)

## Тесты

### Интеграционные

Работают поверх реального PostgreSQL (сервис `postgres_test`) и реальных репозиториев/сервисов, но без запуска HTTP‑сервера — запросы выполняются через Gin в памяти.

```bash
docker compose up -d postgres_test
go test ./tests/integration -count=1
docker compose stop postgres_test
```

### End-to-End

E2E тесты поднимают тот же Gin router через `httptest.Server`: сервис стартует в памяти, а сценарий прогоняется реальным `net/http` клиентом. БД всё так же настоящая (`postgres_test`). При необходимости легко переключиться на dockerized `app` (см. compose файл).

```bash
docker compose up -d postgres_test
go test ./tests/e2e -count=1
docker compose stop postgres_test
```
**Немного про тестовые suite-ы**  
Я знаю, что паттерн с отдельными структурами типа `IntegrationSuite`/`E2ESuite` и общей инициализацией в TestMain — это не совсем по-Goшному (обычно в Go тестах часто используют просто функции и таблицы). Но мне так показалось удобнее для этого проекта — меньше копипасты, удобнее сбрасывать состояние и запускать одни и те же тесты на чистой базе. Ну и для меня так код в тестах чуть чище выглядит.

## Запуск через Docker Compose

`docker compose up`:
- поднимает две БД (`postgres` и `postgres_test`),
- прогоняет миграции для основной БД через сервис `migrations` (образ `migrate/migrate`),
- стартует сервис `app` только после успешных миграций. Переменные окружения читаются из `.env`, но отсутствие файла не ломает старт: можно передать значения через `env_file` или напрямую в `environment`.

При необходимости повторно применить/откатить миграции вручную можно использовать цели `make migrate-up`/`migrate-down`.

## Линт

`make lint` запускает `go vet` и `golangci-lint`. Для линтинга используется стандартная конфигурация без дополнительных настроек, так как в большинстве команд и практик обычно применяют дефолтные параметры.

## Нагрузочное тестирование

Добавлен k6-сценарий `./scripts/load_test/k6.js` (создание команды, затем циклы create PR + getReview). Запуск:

```bash
docker compose up -d   # поднимает postgres + app
make load-test         # def. BASE_URL=http://localhost:8080
```

Если k6 не установлен, можно через контейнер:

```bash
# make load-test сам попытается запустить через локальный k6, иначе через docker grafana/k6
docker run --rm -i -v "$PWD:/scripts" grafana/k6 run /scripts/scripts/load_test/k6.js -e BASE_URL=http://host.docker.internal:8080
```

Thresholds: p95 < 300мс, ошибки < 1%.

Краткий результат последнего прогона (профиль 5 VU, ~50s, BASE_URL=http://host.docker.internal:8080):
- error rate: 0.00% (0/1843)
- p95 http_req_duration: ~129мс (avg ~61мс)
- RPS: ~37 req/s (две операции на итерацию)
